# Завдання
Є *n* мережевих кабелів із заданими довжинами. Необхідно з'єднувати по два кабелі за раз, доки не залишиться один кабель.
Вартість кожного з'єднання дорівнює сумі довжин двох кабелів, які з'єднують. Завдання – **мінімізувати загальну вартість** усіх з'єднань.

## Приклад
Припустимо, маємо кабелі довжин: `[4, 3, 2, 6]`.

1. **Неоптимальний порядок** з'єднання:
   - З'єднати `4` і `3`: вартість = `4 + 3 = 7`; залишилися `[7, 2, 6]`
   - З'єднати `7` і `2`: вартість = `7 + 2 = 9`; залишилися `[9, 6]`
   - З'єднати `9` і `6`: вартість = `9 + 6 = 15`; залишився `[15]`
   - Загальна вартість = `7 + 9 + 15 = 31`

2. **Кращий порядок** з'єднання (завжди беремо найкоротші):
   - З'єднати `2` і `3`: вартість = `5`; залишилися `[5, 4, 6]`
   - З'єднати `4` і `5`: вартість = `9`; залишилися `[9, 6]`
   - З'єднати `9` і `6`: вартість = `15`; залишився `[15]`
   - Загальна вартість = `5 + 9 + 15 = 29`

Як видно, другий спосіб дає меншу загальну вартість.

---

## Ідея розв’язку через **купу**

1. Покласти всі довжини кабелів у **мін-купу**.
2. Ініціалізувати змінну `totalCost = 0`.
3. Поки у купі більше одного кабелю:
   1. Витягнути два **найкоротші** кабелі (наприклад, `x` та `y`).
   2. Обчислити вартість з'єднання: `cost = x + y`.
   3. Додати `cost` до `totalCost`.
   4. Помістити суму `(x + y)` назад у купу.
4. Коли в купі залишиться лише один елемент, усі з’єднання виконано, і `totalCost` міститиме **мінімальну суму** витрат.


## Чому це працює оптимально?

Коли ми об’єднуємо два довгі кабелі на початку, їх сума надалі знову впливає на загальну вартість при наступних об’єднаннях.
Натомість, якщо завжди об’єднувати два найменших, ми “відтерміновуємо” з’єднання довгих відрізків і зменшуємо негативний ефект їх довжини на підсумкову суму.

